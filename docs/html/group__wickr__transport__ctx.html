<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>wickr-crypto-c: Wickr_transport_ctx</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">wickr-crypto-c
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Wickr_transport_ctx</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport context to manage the state machine of a point to point connection using fundamentals of the Wickr protocol as building blocks.  <a href="structwickr__transport__ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwickr__transport__callbacks.html">wickr_transport_callbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">callbacks to notify the user of events within the transport  <a href="structwickr__transport__callbacks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4731758cf20b71d4469c74904bf662c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#ga4731758cf20b71d4469c74904bf662c0">wickr_transport_ctx_create</a> (const <a class="el" href="structwickr__crypto__engine.html">wickr_crypto_engine_t</a> engine, <a class="el" href="structwickr__node.html">wickr_node_t</a> *local_identity, <a class="el" href="structwickr__node.html">wickr_node_t</a> *remote_identity, uint32_t evo_count, <a class="el" href="structwickr__transport__callbacks.html">wickr_transport_callbacks_t</a> callbacks, void *user)</td></tr>
<tr class="separator:ga4731758cf20b71d4469c74904bf662c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa49b2cf44bcb02d656598a17e5ae1c52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#gaa49b2cf44bcb02d656598a17e5ae1c52">wickr_transport_ctx_copy</a> (const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx)</td></tr>
<tr class="separator:gaa49b2cf44bcb02d656598a17e5ae1c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe547b01f4f02efea3f518d7445a71ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#gabe547b01f4f02efea3f518d7445a71ee">wickr_transport_ctx_destroy</a> (<a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> **ctx)</td></tr>
<tr class="separator:gabe547b01f4f02efea3f518d7445a71ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee74761e31d5f0a6fc97e2ccf5ac1e29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#gaee74761e31d5f0a6fc97e2ccf5ac1e29">wickr_transport_ctx_start</a> (<a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx)</td></tr>
<tr class="separator:gaee74761e31d5f0a6fc97e2ccf5ac1e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60dad2360ba29d8c131093a4e9b69057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#ga60dad2360ba29d8c131093a4e9b69057">wickr_transport_ctx_process_tx_buffer</a> (<a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx, const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *buffer)</td></tr>
<tr class="separator:ga60dad2360ba29d8c131093a4e9b69057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0af661e209143c19633e1244ac59db4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#gaa0af661e209143c19633e1244ac59db4">wickr_transport_ctx_process_rx_buffer</a> (<a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx, const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *buffer)</td></tr>
<tr class="separator:gaa0af661e209143c19633e1244ac59db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d3ffde9ec2f9f12ecb6999a048e2437"><td class="memItemLeft" align="right" valign="top">wickr_transport_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#ga3d3ffde9ec2f9f12ecb6999a048e2437">wickr_transport_ctx_get_status</a> (const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx)</td></tr>
<tr class="separator:ga3d3ffde9ec2f9f12ecb6999a048e2437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ec320d2e4a4010ffa3f411c1ea1419a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#ga3ec320d2e4a4010ffa3f411c1ea1419a">wickr_transport_ctx_get_rxstream_user_data</a> (const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx)</td></tr>
<tr class="separator:ga3ec320d2e4a4010ffa3f411c1ea1419a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bcb60a2739744e08cce0c18ce7f01ba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structwickr__node.html">wickr_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#ga7bcb60a2739744e08cce0c18ce7f01ba">wickr_transport_ctx_get_local_node_ptr</a> (const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx)</td></tr>
<tr class="separator:ga7bcb60a2739744e08cce0c18ce7f01ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9baf62b25d23b9c6ecd5cec0fc9d6f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structwickr__node.html">wickr_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#gad9baf62b25d23b9c6ecd5cec0fc9d6f5">wickr_transport_ctx_get_remote_node_ptr</a> (const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx)</td></tr>
<tr class="separator:gad9baf62b25d23b9c6ecd5cec0fc9d6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea14ff3de739f7bf4f85516fdefd1ea9"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#gaea14ff3de739f7bf4f85516fdefd1ea9">wickr_transport_ctx_get_user_ctx</a> (const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx)</td></tr>
<tr class="separator:gaea14ff3de739f7bf4f85516fdefd1ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1865750950d6ff5ba3850c5f03ab3c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#gac1865750950d6ff5ba3850c5f03ab3c9">wickr_transport_ctx_set_user_ctx</a> (<a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx, void *user)</td></tr>
<tr class="separator:gac1865750950d6ff5ba3850c5f03ab3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd4c671c3f420e804dae16c662bc71c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#gabd4c671c3f420e804dae16c662bc71c7">wickr_transport_ctx_get_user_psk</a> (const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx)</td></tr>
<tr class="separator:gabd4c671c3f420e804dae16c662bc71c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffad367319e17f62046cde388ccd8802"><td class="memItemLeft" align="right" valign="top">wickr_transport_data_flow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#gaffad367319e17f62046cde388ccd8802">wickr_transport_ctx_get_data_flow_mode</a> (const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx)</td></tr>
<tr class="separator:gaffad367319e17f62046cde388ccd8802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338125913ff273beec721b341de639a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#ga338125913ff273beec721b341de639a3">wickr_transport_ctx_set_data_flow_mode</a> (<a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx, wickr_transport_data_flow flow_mode)</td></tr>
<tr class="separator:ga338125913ff273beec721b341de639a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc6235ed4ee84ccbdfc3a0a0a617b557"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structwickr__transport__callbacks.html">wickr_transport_callbacks_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#gafc6235ed4ee84ccbdfc3a0a0a617b557">wickr_transport_ctx_get_callbacks</a> (const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx)</td></tr>
<tr class="separator:gafc6235ed4ee84ccbdfc3a0a0a617b557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed375c418ca58c30ca31c8303c71f92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#ga9ed375c418ca58c30ca31c8303c71f92">wickr_transport_ctx_set_callbacks</a> (<a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx, const <a class="el" href="structwickr__transport__callbacks.html">wickr_transport_callbacks_t</a> *callbacks)</td></tr>
<tr class="separator:ga9ed375c418ca58c30ca31c8303c71f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177b8b150fe250cf04f8350be94af7fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__transport__ctx.html#ga177b8b150fe250cf04f8350be94af7fa">wickr_transport_ctx_force_tx_key_evo</a> (<a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *ctx)</td></tr>
<tr class="separator:ga177b8b150fe250cf04f8350be94af7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa49b2cf44bcb02d656598a17e5ae1c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa49b2cf44bcb02d656598a17e5ae1c52">&#9670;&nbsp;</a></span>wickr_transport_ctx_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a>* wickr_transport_ctx_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a transport context</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the transport context to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated transport context holding a deep copy of properties from 'ctx' </dd></dl>

</div>
</div>
<a id="ga4731758cf20b71d4469c74904bf662c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4731758cf20b71d4469c74904bf662c0">&#9670;&nbsp;</a></span>wickr_transport_ctx_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a>* wickr_transport_ctx_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwickr__crypto__engine.html">wickr_crypto_engine_t</a>&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwickr__node.html">wickr_node_t</a> *&#160;</td>
          <td class="paramname"><em>local_identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwickr__node.html">wickr_node_t</a> *&#160;</td>
          <td class="paramname"><em>remote_identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>evo_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwickr__transport__callbacks.html">wickr_transport_callbacks_t</a>&#160;</td>
          <td class="paramname"><em>callbacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a transport context from components</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">engine</td><td>a crypto engine to be used for the underlying signature, and cipher operations </td></tr>
    <tr><td class="paramname">local_identity</td><td>the node information of the person creating the transport context. This should include private signature keys </td></tr>
    <tr><td class="paramname">remote_identity</td><td>the node information of the endpoint 'local_identity' is connecting too. This field is OPTIONAL. If this field is set, the signature keys provided inside this property will be pinned, and the 'on_identity_verify' callback will not be called during connection. The remote_identity passed in here does not need to contain an 'ephemeral_keypair' property, because it will be provided by the remote party during connection, and verified by the node / root signature keys inside the identity </td></tr>
    <tr><td class="paramname">evo_count</td><td>the evolution packet count to be passed to the creation of underlying 'wickr_stream_ctx_t' that are created by this transport internally, see 'wickr_stream_ctx_t' for more information </td></tr>
    <tr><td class="paramname">callbacks</td><td>a set of function pointers the 'wickr_transport_ctx_t' will use to pass data, state change information, and identity verification prompts up to the user for processing. This is the I/O of the transport_ctx </td></tr>
    <tr><td class="paramname">user</td><td>a pointer to be held and passed to all callbacks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated transport context owning the properties passed in </dd></dl>

</div>
</div>
<a id="gabe547b01f4f02efea3f518d7445a71ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe547b01f4f02efea3f518d7445a71ee">&#9670;&nbsp;</a></span>wickr_transport_ctx_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wickr_transport_ctx_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> **&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a transport context</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to the transport context to destroy. All properties of '*ctx' will also be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga177b8b150fe250cf04f8350be94af7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga177b8b150fe250cf04f8350be94af7fa">&#9670;&nbsp;</a></span>wickr_transport_ctx_force_tx_key_evo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wickr_transport_ctx_force_tx_key_evo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Force the tx stream to perform a tx stream key evolution immediately</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the transport context evolove the tx stream key of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key evolution was successful </dd></dl>

</div>
</div>
<a id="gafc6235ed4ee84ccbdfc3a0a0a617b557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc6235ed4ee84ccbdfc3a0a0a617b557">&#9670;&nbsp;</a></span>wickr_transport_ctx_get_callbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structwickr__transport__callbacks.html">wickr_transport_callbacks_t</a>* wickr_transport_ctx_get_callbacks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the current set of callbacks for a transport</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the transport context to get the callbacks of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the current set of callbacks the transport is using </dd></dl>

</div>
</div>
<a id="gaffad367319e17f62046cde388ccd8802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffad367319e17f62046cde388ccd8802">&#9670;&nbsp;</a></span>wickr_transport_ctx_get_data_flow_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wickr_transport_data_flow wickr_transport_ctx_get_data_flow_mode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current data flow mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the transport context to get the data flow mode of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current data flow mode for 'ctx', see 'wickr_transport_data_flow' for more info </dd></dl>

</div>
</div>
<a id="ga7bcb60a2739744e08cce0c18ce7f01ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bcb60a2739744e08cce0c18ce7f01ba">&#9670;&nbsp;</a></span>wickr_transport_ctx_get_local_node_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structwickr__node.html">wickr_node_t</a>* wickr_transport_ctx_get_local_node_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the local node information</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the transport context to get the local node information of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local node information or NULL if no information is available due to the state of the transport context </dd></dl>

</div>
</div>
<a id="gad9baf62b25d23b9c6ecd5cec0fc9d6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9baf62b25d23b9c6ecd5cec0fc9d6f5">&#9670;&nbsp;</a></span>wickr_transport_ctx_get_remote_node_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structwickr__node.html">wickr_node_t</a>* wickr_transport_ctx_get_remote_node_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the remote node information</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the transport context to get the remote node information of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>remote node information or NULL if no information is available due to the state of the transport context </dd></dl>

</div>
</div>
<a id="ga3ec320d2e4a4010ffa3f411c1ea1419a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ec320d2e4a4010ffa3f411c1ea1419a">&#9670;&nbsp;</a></span>wickr_transport_ctx_get_rxstream_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a>* wickr_transport_ctx_get_rxstream_user_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the user data associated with the current rx stream's stream key</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the transport context to get the rx stream user data of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current rx stream key's user data field, or NULL if no data is available </dd></dl>

</div>
</div>
<a id="ga3d3ffde9ec2f9f12ecb6999a048e2437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d3ffde9ec2f9f12ecb6999a048e2437">&#9670;&nbsp;</a></span>wickr_transport_ctx_get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wickr_transport_status wickr_transport_ctx_get_status </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current status of a transport context</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the transport context to get the status of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current status of 'ctx' </dd></dl>

</div>
</div>
<a id="gaea14ff3de739f7bf4f85516fdefd1ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea14ff3de739f7bf4f85516fdefd1ea9">&#9670;&nbsp;</a></span>wickr_transport_ctx_get_user_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* wickr_transport_ctx_get_user_ctx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current user context pointer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the context to get the user context pointer of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current user context pointer </dd></dl>

</div>
</div>
<a id="gabd4c671c3f420e804dae16c662bc71c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd4c671c3f420e804dae16c662bc71c7">&#9670;&nbsp;</a></span>wickr_transport_ctx_get_user_psk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a>* wickr_transport_ctx_get_user_psk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current user PSK, see 'wickr_transport_ctx_set_user_psk' for more information</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the transport context to get the psk data from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current psk data for 'ctx' </dd></dl>

</div>
</div>
<a id="gaa0af661e209143c19633e1244ac59db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0af661e209143c19633e1244ac59db4">&#9670;&nbsp;</a></span>wickr_transport_ctx_process_rx_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a>* wickr_transport_ctx_process_rx_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process a buffer that was received from the remote via a transport layer. This may include handshake data or encrypted content</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the context to process the buffer with </td></tr>
    <tr><td class="paramname">buffer</td><td>the buffer to be processed by by 'ctx' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the decoded tx buffer or NULL if decryption fails. As with all other incoming packets, it will also trigger a rx callback </dd></dl>

</div>
</div>
<a id="ga60dad2360ba29d8c131093a4e9b69057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60dad2360ba29d8c131093a4e9b69057">&#9670;&nbsp;</a></span>wickr_transport_ctx_process_tx_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a>* wickr_transport_ctx_process_tx_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process a buffer that should be sent to the remote party</p>
<p>NOTE: This function requires the transport context to be in ACTIVE status, attempting to process a tx buffer in any other state will cause the transport to enter the error status. When the buffer has completed processing the encrypted payload will be passed back via the wickr_transport_tx_func callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the context to process the buffer with </td></tr>
    <tr><td class="paramname">buffer</td><td>the buffer to be encrypted and sent over the transport </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the decoded tx buffer or NULL if decryption fails. As with all other incoming packets, it will also trigger a rx callback </dd></dl>

</div>
</div>
<a id="ga9ed375c418ca58c30ca31c8303c71f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ed375c418ca58c30ca31c8303c71f92">&#9670;&nbsp;</a></span>wickr_transport_ctx_set_callbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wickr_transport_ctx_set_callbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structwickr__transport__callbacks.html">wickr_transport_callbacks_t</a> *&#160;</td>
          <td class="paramname"><em>callbacks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the callbacks of a transport after it's creation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the transport context to set the callbacks of </td></tr>
    <tr><td class="paramname">callbacks</td><td>the callbacks that transport should use after calling this function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga338125913ff273beec721b341de639a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga338125913ff273beec721b341de639a3">&#9670;&nbsp;</a></span>wickr_transport_ctx_set_data_flow_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wickr_transport_ctx_set_data_flow_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wickr_transport_data_flow&#160;</td>
          <td class="paramname"><em>flow_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the the data flow mode. This change will be applied immediatly</p>
<p>If the mode is READ_ONLY, attempting to write a packet will silently fail If the mode iw WRITE_ONLY, any incoming packets will be silently dropped</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the transport context to set the data flow mode of </td></tr>
    <tr><td class="paramname">flow_mode</td><td>the flow mode you would like to enact </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac1865750950d6ff5ba3850c5f03ab3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1865750950d6ff5ba3850c5f03ab3c9">&#9670;&nbsp;</a></span>wickr_transport_ctx_set_user_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wickr_transport_ctx_set_user_ctx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a user context pointer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the transport context to set the user supplied context info to </td></tr>
    <tr><td class="paramname">user</td><td>the pointer for the transport context to hold and be passed back in callbacks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee74761e31d5f0a6fc97e2ccf5ac1e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee74761e31d5f0a6fc97e2ccf5ac1e29">&#9670;&nbsp;</a></span>wickr_transport_ctx_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wickr_transport_ctx_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwickr__transport__ctx.html">wickr_transport_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the transport 3 way handshake to establish stream cipher keys and begin secure communication. This function can also be used to reestablish a new set of cipher keys if a handshake had previously been completed.</p>
<p>When handshake data is generated, the 'wickr_transport_tx_func' callback will be fired so that it can be forwarded via the proper communication channel. Handshake responses can be passed back into the transport context via the 'wickr_transport_ctx_process_rx_buffer' function. The 'on_state' callback of the transport will be fired to indicate the various stages of the handshake reaching completion, or an error occuring. User data may be passed into the 'wickr_transport_ctx_process_tx_buffer' function after the transport status reaches 'TRANSPORT_STATUS_ACTIVE'. If 'remote_identity' was not set during creation, and thus no remote key information is pinned, the 'on_identity_verify' callback will be called for the application to verify the integrity of the remote's identity via cached information, or whatever other means it has.</p>
<p>Optional callbacks will also be called for when a pre-shared key is required for the key exchange to successfully complete, and when the tx stream is being generated to allow for customization of tx stream key generation and to update the user data field of the tx stream's key</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the transport to start the handshake on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
